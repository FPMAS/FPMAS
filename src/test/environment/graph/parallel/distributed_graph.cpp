#include "gtest/gtest.h"

#include "communication/communication.h"
#include "environment/graph/parallel/distributed_graph.h"
#include "environment/graph/parallel/zoltan_fn.h"
#include "utils/config.h"

#include "test_utils/test_utils.h"

using FPMAS::communication::MpiCommunicator;

using FPMAS::graph::DistributedGraph;

using FPMAS::test_utils::assert_contains;

using FPMAS::graph::zoltan::write_zoltan_id;

using FPMAS::graph::zoltan::obj_list;
using FPMAS::graph::zoltan::num_edges_multi_fn;
using FPMAS::graph::zoltan::node_obj_size_multi_fn;
using FPMAS::graph::zoltan::node_pack_obj_multi_fn;

class Mpi_ZoltanFunctionsTest : public ::testing::Test {
	protected:
		static Zoltan* zz;
		static MpiCommunicator* mpiCommunicator;

		static std::array<int*, 3> data;

		static void SetUpTestSuite() {
			mpiCommunicator = new MpiCommunicator();
			zz = new Zoltan(mpiCommunicator->getMpiComm());
			FPMAS::config::zoltan_config(zz);

			for(int i = 0; i < 3; i++) {
				data[i] = new int(i);
			}
		}

		DistributedGraph<int> dg = DistributedGraph<int>(zz);

		// Fake Zoltan buffers
		
		// Node lists
		unsigned int global_ids[6];
		unsigned int local_ids[0];
		float weights[3];

		// Resulting global ids
		int node1_index;
		int node2_index;
		int node3_index;

		// Edge lists
		int num_edges[3];

		// Migration
		unsigned int transfer_global_ids[4];
		int sizes[2];
		int idx[2];
		char buf[66];

		// Error code
		int err;

		void SetUp() override {
			dg.buildNode(0, 1., data[0]);
			dg.buildNode(2, 2., data[1]);
			dg.buildNode(85250, 3., data[2]);

			dg.link(0, 2, 0);
			dg.link(2, 0, 1);

			dg.link(0, 85250, 2);


		}

		void write_zoltan_global_ids() {
			obj_list<int>(
					&dg,
					2,
					0,
					global_ids,
					local_ids,
					1,
					weights,
					&err
					);

			// We don't know in which order nodes will be processed internally.
			// So, for the purpose of the test, we use weights to find which node
			// correspond to which index in weights and global_ids.
			assert_contains<float, 3>(weights, 1., &node1_index);
			assert_contains<float, 3>(weights, 2., &node2_index);
			assert_contains<float, 3>(weights, 3., &node3_index);
		}

		void write_zoltan_num_edges() {
			num_edges_multi_fn<int>(
					&dg,
					2,
					0,
					3,
					global_ids,
					local_ids,
					num_edges,
					&err
					);
		}

		void write_migration_sizes() {
			// Transfer nodes 0 and 85250
			write_zoltan_id(0, &transfer_global_ids[0]);
			write_zoltan_id(85250, &transfer_global_ids[2]);

			node_obj_size_multi_fn<int>(
					&dg,
					2,
					0,
					2,
					transfer_global_ids,
					local_ids,
					sizes,
					&err
					);
		}

		void write_communication_buffer() {
			// Automatically generated by Zoltan in a real use case
			idx[0] = 0;
			idx[1] = sizes[0] + 1;

			// Unused
			int dest[2];

			node_pack_obj_multi_fn<int>(
					&dg,
					2,
					0,
					2,
					transfer_global_ids,
					local_ids,
					dest,
					sizes,
					idx,
					buf,
					&err
					);
		}

		static void TearDownTestSuite() {
			delete zz;
			delete mpiCommunicator;
			for(auto i : data) {
				delete i;
			}
		}
};
MpiCommunicator* Mpi_ZoltanFunctionsTest::mpiCommunicator = nullptr;
Zoltan* Mpi_ZoltanFunctionsTest::zz = nullptr;
std::array<int*, 3> Mpi_ZoltanFunctionsTest::data;


TEST_F(Mpi_ZoltanFunctionsTest, obj_list_fn_test) {

	write_zoltan_global_ids();

	ASSERT_EQ(FPMAS::graph::zoltan::read_zoltan_id(&global_ids[2 * node1_index]), 0ul);
	ASSERT_EQ(FPMAS::graph::zoltan::read_zoltan_id(&global_ids[2 * node2_index]), 2ul);
	ASSERT_EQ(FPMAS::graph::zoltan::read_zoltan_id(&global_ids[2 * node3_index]), 85250ul);
}


TEST_F(Mpi_ZoltanFunctionsTest, obj_num_egdes_multi_test) {

	write_zoltan_global_ids();

	write_zoltan_num_edges();

	// Node 0 has 2 outgoing arcs
	ASSERT_EQ(num_edges[node1_index], 2);
	// Node 1 has 1 outgoing arcs
	ASSERT_EQ(num_edges[node2_index], 1);
	// Node 2 has 0 outgoing arcs
	ASSERT_EQ(num_edges[node3_index], 0);
}

using FPMAS::graph::zoltan::edge_list_multi_fn;


TEST_F(Mpi_ZoltanFunctionsTest, edge_list_multi_test) {

	write_zoltan_global_ids();

	write_zoltan_num_edges();

	unsigned int nbor_global_id[6];
	int nbor_procs[3];
	float ewgts[3];

	edge_list_multi_fn<int>(
			&dg,
			2,
			0,
			3,
			global_ids,
			local_ids,
			num_edges,
			nbor_global_id,
			nbor_procs,
			1,
			ewgts,
			&err
			);

	int node1_offset = node1_index < node2_index ? 0 : 1;
	int node2_offset = node1_index < node2_index ? 2 : 0;

	unsigned long node1_edges[] = {
		FPMAS::graph::zoltan::read_zoltan_id(&nbor_global_id[(node1_offset) * 2]),
		FPMAS::graph::zoltan::read_zoltan_id(&nbor_global_id[(node1_offset + 1) * 2]),
	};

	assert_contains<unsigned long, 2>(node1_edges, 2);
	assert_contains<unsigned long, 2>(node1_edges, 85250);

	ASSERT_EQ(FPMAS::graph::zoltan::read_zoltan_id(&nbor_global_id[node2_offset * 2]), 0);

	for(int i = 0; i < 3; i++) {
		ASSERT_EQ(ewgts[i], 1.f);
	}

}


TEST_F(Mpi_ZoltanFunctionsTest, obj_size_multi_test) {

	write_migration_sizes();

	json node1_str = *dg.getNodes().at(0);
	ASSERT_EQ(sizes[0], node1_str.dump().size() + 1);

	json node2_str = *dg.getNodes().at(85250);
	ASSERT_EQ(sizes[1], node2_str.dump().size() + 1);
}


TEST_F(Mpi_ZoltanFunctionsTest, pack_obj_multi_test) {

	write_migration_sizes();
	write_communication_buffer();

	// Decompose and check buffer data
	ASSERT_EQ(
		*&buf[0],
		*R"({"data":0,"id":0})"
		);

	ASSERT_EQ(
		*&buf[idx[1]],
		*R"({"data":2,"id":85250})"
		);
}

using FPMAS::graph::zoltan::node_unpack_obj_multi_fn;

TEST_F(Mpi_ZoltanFunctionsTest, unpack_obj_multi_test) {

	write_migration_sizes();
	write_communication_buffer();

	DistributedGraph<int> g = DistributedGraph<int>(zz);
	node_unpack_obj_multi_fn<int>(
		&g,
		2,
		2,
		transfer_global_ids,
		sizes,
		idx,
		buf,
		&err);

	ASSERT_EQ(g.getNodes().size(), 2);

	ASSERT_EQ(g.getNodes().count(0), 1);
	FPMAS::graph::Node<int>* node0 = g.getNodes().at(0);
	ASSERT_EQ(node0->getId(), 0);
	ASSERT_EQ(*node0->getData(), 0);
	ASSERT_EQ(node0->getWeight(), 1.f);

	ASSERT_EQ(g.getNodes().count(85250ul), 1);
	FPMAS::graph::Node<int>* node1 = g.getNodes().at(85250);
	ASSERT_EQ(node1->getId(), 85250ul);
	ASSERT_EQ(*node1->getData(), 2);
	ASSERT_EQ(node1->getWeight(), 3.f);

}

using FPMAS::graph::zoltan::node_mid_migrate_pp_fn;

// Only modify graph private internal structure (set up arc export lists)
// In consecuence, no real assertion is made there, but the function is still
// executed to check for memory issues or other runtime errors
TEST_F(Mpi_ZoltanFunctionsTest, mig_migrate_test) {
	unsigned int export_global_ids[4];
	write_zoltan_id(0ul, &export_global_ids[0]);
	write_zoltan_id(85250ul, &export_global_ids[2]);

	// Fake export info
	int export_procs[2] = {0, 1};
	int export_parts[2] = {0, 1};

	node_mid_migrate_pp_fn<int>(
		&dg,
		2,
		0,
		0,
		nullptr,
		nullptr,
		nullptr,
		nullptr,
		2,
		export_global_ids,
		nullptr,
		export_procs,
		export_parts,
		&err);

	/*
	ASSERT_EQ(dg.getNodes().size(), 1);
	ASSERT_EQ(dg.getArcs().size(), 0);
	ASSERT_EQ(dg.getNodes().at(2ul)->getIncomingArcs().size(), 0);
	ASSERT_EQ(dg.getNodes().at(2ul)->getOutgoingArcs().size(), 0);
	*/
}


class Mpi_DistributeGraphTest : public ::testing::Test {
	protected:
		static MpiCommunicator* mpiCommunicator;
		static Zoltan* zz;

		DistributedGraph<int> dg = DistributedGraph<int>(zz);
		std::vector<int*> data;

		static void SetUpTestSuite() {
			mpiCommunicator = new MpiCommunicator();
			zz = new Zoltan(mpiCommunicator->getMpiComm());
			FPMAS::config::zoltan_config(zz);
		}

		void SetUp() override {
			if(mpiCommunicator->getRank() == 0) {
				for (int i = 0; i < mpiCommunicator->getSize(); ++i) {
					data.push_back(new int(i));
					dg.buildNode((unsigned long) i, data.back());
				}
			}
		}

		void TearDown() override {
			for(auto d : data) {
				delete d;
			}
		}


		static void TearDownTestSuite() {
			delete zz;
			delete mpiCommunicator;
		}
};

MpiCommunicator* Mpi_DistributeGraphTest::mpiCommunicator = nullptr;
Zoltan* Mpi_DistributeGraphTest::zz = nullptr;

TEST_F(Mpi_DistributeGraphTest, distribute_test) {
	if(mpiCommunicator->getRank() == 0) {
		ASSERT_EQ(dg.getNodes().size(), mpiCommunicator->getSize());
	}
	else {
		ASSERT_EQ(dg.getNodes().size(), 0);
	}

	int result = dg.distribute();

	ASSERT_EQ(result, ZOLTAN_OK);
	ASSERT_EQ(dg.getNodes().size(), 1);
}
