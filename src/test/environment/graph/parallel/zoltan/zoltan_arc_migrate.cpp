#include "gtest/gtest.h"

#include "communication/communication.h"
#include "environment/graph/parallel/distributed_graph.h"
#include "environment/graph/parallel/zoltan/zoltan_lb.h"
#include "utils/config.h"

#include "test_utils/test_utils.h"

using FPMAS::communication::MpiCommunicator;

using FPMAS::graph::zoltan::utils::write_zoltan_id;

using FPMAS::graph::zoltan::arc::obj_size_multi_fn;
using FPMAS::graph::zoltan::arc::pack_obj_multi_fn;

class Mpi_ZoltanArcMigrationFunctionsTest : public ::testing::Test {
	protected:
		static Zoltan* zz;
		static MpiCommunicator* mpiCommunicator;

		static std::array<int*, 3> data;

		static void SetUpTestSuite() {
			mpiCommunicator = new MpiCommunicator();
			zz = new Zoltan(mpiCommunicator->getMpiComm());
			FPMAS::config::zoltan_config(zz);

			for(int i = 0; i < 3; i++) {
				data[i] = new int(i);
			}
		}

		DistributedGraph<int> dg = DistributedGraph<int>(zz);

		// Migration
		unsigned int transfer_arc_global_ids[4];
		int sizes[2];
		int idx[2];
		char buf[66];

		// Error code
		int err;

		void SetUp() override {
			dg.buildNode(0, 1., data[0]);
			dg.buildNode(2, 2., data[1]);
			dg.buildNode(85250, 3., data[2]);

			dg.link(0, 2, 0);
			dg.link(2, 0, 1);

			dg.link(0, 85250, 2);


		}

		void write_migration_sizes() {
			// Transfer arcs 0 and 2
			write_zoltan_id(0, &transfer_arc_global_ids[0]);
			write_zoltan_id(2, &transfer_arc_global_ids[2]);

			obj_size_multi_fn<int>(
					&dg,
					2,
					0,
					2,
					transfer_arc_global_ids,
					nullptr,
					sizes,
					&err
					);
		}

		void write_communication_buffer() {
			// Automatically generated by Zoltan in a real use case
			idx[0] = 0;
			idx[1] = sizes[0] + 1;

			// Unused
			int dest[2];

			pack_obj_multi_fn<int>(
					&dg,
					2,
					0,
					2,
					transfer_arc_global_ids,
					nullptr,
					dest,
					sizes,
					idx,
					buf,
					&err
					);
		}

		static void TearDownTestSuite() {
			delete zz;
			delete mpiCommunicator;
			for(auto i : data) {
				delete i;
			}
		}
};
MpiCommunicator* Mpi_ZoltanArcMigrationFunctionsTest::mpiCommunicator = nullptr;
Zoltan* Mpi_ZoltanArcMigrationFunctionsTest::zz = nullptr;
std::array<int*, 3> Mpi_ZoltanArcMigrationFunctionsTest::data;

TEST_F(Mpi_ZoltanArcMigrationFunctionsTest, obj_size_multi_test) {

	write_migration_sizes();

	json arc0_str = *dg.getArcs().at(0);
	ASSERT_EQ(sizes[0], arc0_str.dump().size() + 1);

	json arc2_str = *dg.getArcs().at(2);
	ASSERT_EQ(sizes[1], arc2_str.dump().size() + 1);
}

TEST_F(Mpi_ZoltanArcMigrationFunctionsTest, pack_obj_multi_test) {

	write_migration_sizes();
	write_communication_buffer();

	// Decompose and check buffer data
	ASSERT_STREQ(
		&buf[0],
		R"({"id":0,"link":[0,2]})"
		);

	ASSERT_STREQ(
		&buf[idx[1]],
		R"({"id":2,"link":[0,85250]})"
		);
}

using FPMAS::graph::zoltan::arc::unpack_obj_multi_fn;

/*
 * Unpack test, with source and target nodes of the unpacked arcs contained in
 * the local graph, so that they can be rebuilt normally.
 */
TEST_F(Mpi_ZoltanArcMigrationFunctionsTest, local_nodes_unpack_obj_multi_test) {

	write_migration_sizes();
	write_communication_buffer();

	dg.unlink(0ul);
	dg.unlink(2ul);
	unpack_obj_multi_fn<int>(
		&dg,
		2,
		2,
		transfer_arc_global_ids,
		sizes,
		idx,
		buf,
		&err);

	ASSERT_EQ(dg.getArcs().size(), 3);

	ASSERT_EQ(dg.getNode(0ul)->getOutgoingArcs().size(), 2);
	ASSERT_EQ(dg.getNode(2ul)->getIncomingArcs().size(), 1);
	ASSERT_EQ(dg.getNode(85250ul)->getIncomingArcs().size(), 1);

	ASSERT_EQ(dg.getNode(2ul)->getIncomingArcs().at(0)->getId(), 0ul);
	ASSERT_EQ(dg.getArc(0ul)->getSourceNode()->getId(), 0ul);
	ASSERT_EQ(dg.getArc(0ul)->getTargetNode()->getId(), 2ul);

	ASSERT_EQ(dg.getNode(85250ul)->getIncomingArcs().at(0)->getId(), 2ul);
	ASSERT_EQ(dg.getArc(2ul)->getSourceNode()->getId(), 0ul);
	ASSERT_EQ(dg.getArc(2ul)->getTargetNode()->getId(), 85250ul);
}

