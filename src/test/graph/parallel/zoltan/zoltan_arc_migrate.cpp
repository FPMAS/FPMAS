#include "gtest/gtest.h"

#include "communication/communication.h"
#include "graph/parallel/distributed_graph.h"
#include "graph/parallel/zoltan/zoltan_lb.h"
#include "utils/config.h"
#include "graph/parallel/synchro/ghost_mode.h"

#include "utils/test.h"

using FPMAS::communication::MpiCommunicator;

using FPMAS::graph::parallel::zoltan::utils::write_zoltan_id;

using FPMAS::graph::parallel::zoltan::arc::obj_size_multi_fn;
using FPMAS::graph::parallel::zoltan::arc::pack_obj_multi_fn;

using FPMAS::graph::parallel::DistributedGraph;

using FPMAS::graph::parallel::synchro::modes::GhostMode;

class Mpi_ZoltanArcMigrationFunctionsTest : public ::testing::Test {
	protected:
		DistributedGraph<int> dg;

		// Migration
		unsigned int transfer_arc_global_ids[4];
		int sizes[2];
		int idx[2];
		char buf[250];

		// Error code
		int err;

		DistributedId id1;
		DistributedId id2;
		DistributedId id3;

		DistributedId arcId1;
		DistributedId arcId2;

		void SetUp() override {
			id1 = dg.buildNode(1., 0)->getId();
			id2 = dg.buildNode(2., 1)->getId();
			id3 = dg.buildNode(3., 2)->getId();

			arcId1 = dg.link(id1, id2)->getId();
			dg.link(id2, id1);

			arcId2 = dg.link(id1, id3)->getId();
		}

		void write_migration_sizes() {
			// Transfer arcs 0 and 2
			write_zoltan_id(arcId1, &transfer_arc_global_ids[0]);
			write_zoltan_id(arcId2, &transfer_arc_global_ids[2]);

			obj_size_multi_fn<int, 1, GhostMode>(
					&dg,
					2,
					0,
					2,
					transfer_arc_global_ids,
					nullptr,
					sizes,
					&err
					);
		}

		void write_communication_buffer() {
			// Automatically generated by Zoltan in a real use case
			idx[0] = 0;
			idx[1] = sizes[0] + 1;

			// Unused
			int dest[2];

			pack_obj_multi_fn<int, 1, GhostMode>(
					&dg,
					2,
					0,
					2,
					transfer_arc_global_ids,
					nullptr,
					dest,
					sizes,
					idx,
					buf,
					&err
					);
		}
};

TEST_F(Mpi_ZoltanArcMigrationFunctionsTest, obj_size_multi_test) {

	write_migration_sizes();

	int current_proc = dg.getMpiCommunicator().getRank();
	json arc0_str = *dg.getArcs().at(arcId1);
	arc0_str["source"] = {current_proc, current_proc};
	arc0_str["target"] = {current_proc, current_proc};
	ASSERT_EQ(sizes[0], arc0_str.dump().size() + 1);

	json arc2_str = *dg.getArcs().at(arcId2);
	arc2_str["source"] = {current_proc, current_proc};
	arc2_str["target"] = {current_proc, current_proc};
	ASSERT_EQ(sizes[1], arc2_str.dump().size() + 1);
}

TEST_F(Mpi_ZoltanArcMigrationFunctionsTest, pack_obj_multi_test) {

	write_migration_sizes();
	write_communication_buffer();

	std::string current_proc = std::to_string(dg.getMpiCommunicator().getRank());

	// Decompose and check buffer data
	ASSERT_STREQ(
		&buf[0],
		std::string(
			R"({"id":{"id":0,"rank":)" + current_proc 
			+ R"(},"layer":0,"link":[)"
			+ R"({"id":0,"rank":)"+current_proc +"},"
			+ R"({"id":1,"rank":)"+current_proc +"}"
			+ R"(],"source":[)" + current_proc + "," + current_proc + "],"
			+ R"("target":[)" + current_proc + "," + current_proc + "]}"
			).c_str()
		);

	ASSERT_STREQ(
		&buf[idx[1]],
		std::string(
			R"({"id":{"id":2,"rank":)" + current_proc
			+ R"(},"layer":0,"link":[)"
			+ R"({"id":0,"rank":)"+current_proc +"},"
			+ R"({"id":2,"rank":)"+current_proc +"}"
			+ R"(],"source":[)"
			+ current_proc + "," + current_proc + "],"
			+ R"("target":[)" + current_proc + "," + current_proc + "]}"
			).c_str()
		);
}

using FPMAS::graph::parallel::zoltan::arc::unpack_obj_multi_fn;

/*
 * Unpack test, with source and target nodes of the unpacked arcs contained in
 * the local graph, so that they can be rebuilt normally.
 */
TEST_F(Mpi_ZoltanArcMigrationFunctionsTest, local_nodes_unpack_obj_multi_test) {

	write_migration_sizes();
	write_communication_buffer();

	dg.unlink(arcId1);
	dg.unlink(arcId2);
	ASSERT_EQ(dg.getArcs().size(), 1);
	unpack_obj_multi_fn<int, 1, GhostMode>(
		&dg,
		2,
		2,
		transfer_arc_global_ids,
		sizes,
		idx,
		buf,
		&err);

	ASSERT_EQ(dg.getArcs().size(), 3);

	ASSERT_EQ(dg.getNode(id1)->getOutgoingArcs().size(), 2);
	ASSERT_EQ(dg.getNode(id2)->getIncomingArcs().size(), 1);
	ASSERT_EQ(dg.getNode(id3)->getIncomingArcs().size(), 1);

	ASSERT_EQ(dg.getNode(id2)->getIncomingArcs().at(0)->getId(), arcId1);
	ASSERT_EQ(dg.getArc(arcId1)->getSourceNode()->getId(), id1);
	ASSERT_EQ(dg.getArc(arcId1)->getTargetNode()->getId(), id2);

	ASSERT_EQ(dg.getNode(id3)->getIncomingArcs().at(0)->getId(), arcId2);
	ASSERT_EQ(dg.getArc(arcId2)->getSourceNode()->getId(), id1);
	ASSERT_EQ(dg.getArc(arcId2)->getTargetNode()->getId(), id3);
}

