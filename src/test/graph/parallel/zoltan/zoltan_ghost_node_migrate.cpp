#include "gtest/gtest.h"

#include "graph/parallel/distributed_graph.h"
#include "graph/parallel/synchro/ghost_mode.h"

using FPMAS::graph::parallel::zoltan::ghost::obj_size_multi_fn;
using FPMAS::graph::parallel::zoltan::ghost::pack_obj_multi_fn;

using FPMAS::graph::parallel::DistributedGraph;

using FPMAS::graph::parallel::synchro::modes::GhostMode;

class Mpi_ZoltanGhostNodeMigrationFunctionsTest : public ::testing::Test {
	protected:
		DistributedGraph<int> dg = DistributedGraph<int>();

		// Migration
		unsigned int transfer_global_ids[4];
		int sizes[2];
		int idx[2];
		char buf[250];

		// Error code
		int err;

		DistributedId id1;
		DistributedId id2;

		void SetUp() override {
			id1 = dg.buildNode(1.5f, 1)->getId();
			id2 = dg.buildNode(2.f, -2)->getId();
		}

		void write_migration_sizes() {
			// Transfer nodes 0 and 1
			FPMAS::graph::parallel::zoltan::utils::write_zoltan_id(id1, &transfer_global_ids[0]);
			FPMAS::graph::parallel::zoltan::utils::write_zoltan_id(id2, &transfer_global_ids[2]);

			obj_size_multi_fn<int, 1, GhostMode>(
					&dg,
					2,
					0,
					2,
					transfer_global_ids,
					nullptr,
					sizes,
					&err
					);
		}

		void write_communication_buffer() {
			// Automatically generated by Zoltan in a real use case
			idx[0] = 0;
			idx[1] = sizes[0] + 1;

			// Unused
			int dest[2];

			pack_obj_multi_fn<int, 1, GhostMode>(
					&dg,
					2,
					0,
					2,
					transfer_global_ids,
					nullptr,
					dest,
					sizes,
					idx,
					buf,
					&err
					);
		}
};

TEST_F(Mpi_ZoltanGhostNodeMigrationFunctionsTest, obj_size_multi_test) {

	write_migration_sizes();

	json ghost0_str = *dg.getNodes().at(id1);
	ASSERT_EQ(sizes[0], ghost0_str.dump().size() + 1);

	json ghost1_str = *dg.getNodes().at(id2);
	ASSERT_EQ(sizes[1], ghost1_str.dump().size() + 1);
}

TEST_F(Mpi_ZoltanGhostNodeMigrationFunctionsTest, pack_obj_multi_test) {

	write_migration_sizes();
	write_communication_buffer();

	std::string current_proc = std::to_string(dg.getMpiCommunicator().getRank());
	ASSERT_STREQ(
		&buf[0],
		std::string(
			R"({"data":{"schedule":0,"value":1},"id":[)" + current_proc + R"(,0])"
			+ R"(,"weight":1.5})"
			).c_str()
		);

	ASSERT_STREQ(
		&buf[idx[1]],
		std::string(
			R"({"data":{"schedule":0,"value":-2},"id":[)" + current_proc + R"(,1])"
			+ R"(,"weight":2.0})"
			).c_str()
		);

}

using FPMAS::graph::parallel::zoltan::ghost::unpack_obj_multi_fn;

TEST_F(Mpi_ZoltanGhostNodeMigrationFunctionsTest, unpack_obj_multi_test) {

	dg.getNode(id1)->data()->acquire() = 8;
	dg.getNode(id1)->setWeight(5.);

	dg.getNode(id2)->data()->acquire() = 12;
	dg.getNode(id2)->setWeight(4.);

	write_migration_sizes();
	write_communication_buffer();
	
	dg.getGhost().buildNode(*dg.getNode(id1));
	dg.getGhost().buildNode(*dg.getNode(id2));

	dg.removeNode(id1);
	dg.removeNode(id2);

	unpack_obj_multi_fn<int, 1, GhostMode>(
		&dg,
		2,
		2,
		transfer_global_ids,
		sizes,
		idx,
		buf,
		&err);

	ASSERT_EQ(dg.getGhost().getNodes().at(id1)->data()->read(), 8);
	ASSERT_EQ(dg.getGhost().getNodes().at(id1)->getWeight(), 5.);

	ASSERT_EQ(dg.getGhost().getNodes().at(id2)->data()->read(), 12);
	ASSERT_EQ(dg.getGhost().getNodes().at(id2)->getWeight(), 4.);
}
