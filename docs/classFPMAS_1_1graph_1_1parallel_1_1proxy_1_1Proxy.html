<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fpmas: FPMAS::graph::parallel::proxy::Proxy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fpmas
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>FPMAS</b></li><li class="navelem"><a class="el" href="namespaceFPMAS_1_1graph.html">graph</a></li><li class="navelem"><a class="el" href="namespaceFPMAS_1_1graph_1_1parallel.html">parallel</a></li><li class="navelem"><a class="el" href="namespaceFPMAS_1_1graph_1_1parallel_1_1proxy.html">proxy</a></li><li class="navelem"><a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1proxy_1_1Proxy.html">Proxy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classFPMAS_1_1graph_1_1parallel_1_1proxy_1_1Proxy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FPMAS::graph::parallel::proxy::Proxy Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="proxy_8h_source.html">proxy.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac57c3711fb82615b38fe2748aaaf8c6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1proxy_1_1Proxy.html#ac57c3711fb82615b38fe2748aaaf8c6b">Proxy</a> (int localProc)</td></tr>
<tr class="separator:ac57c3711fb82615b38fe2748aaaf8c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576ec70cdd4ad246cc06e3ac8ca9a575"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1proxy_1_1Proxy.html#a576ec70cdd4ad246cc06e3ac8ca9a575">Proxy</a> (int localProc, std::initializer_list&lt; int &gt;)</td></tr>
<tr class="separator:a576ec70cdd4ad246cc06e3ac8ca9a575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b90abd4c342da8219e3b317875e95a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1proxy_1_1Proxy.html#a0b90abd4c342da8219e3b317875e95a3">getLocalProc</a> () const</td></tr>
<tr class="separator:a0b90abd4c342da8219e3b317875e95a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599bab0819fb0dd336120fa954571ac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1proxy_1_1Proxy.html#a599bab0819fb0dd336120fa954571ac2">setOrigin</a> (unsigned long, int)</td></tr>
<tr class="separator:a599bab0819fb0dd336120fa954571ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9c8f41ffb64f655ad8cb787990cbf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1proxy_1_1Proxy.html#a5d9c8f41ffb64f655ad8cb787990cbf7">setCurrentLocation</a> (unsigned long, int)</td></tr>
<tr class="separator:a5d9c8f41ffb64f655ad8cb787990cbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32ea09361e39373cff62ba1de5ea244"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1proxy_1_1Proxy.html#ae32ea09361e39373cff62ba1de5ea244">getOrigin</a> (unsigned long) const</td></tr>
<tr class="separator:ae32ea09361e39373cff62ba1de5ea244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ff3d0e22aa7d489b9713054847ede8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1proxy_1_1Proxy.html#af4ff3d0e22aa7d489b9713054847ede8">getCurrentLocation</a> (unsigned long) const</td></tr>
<tr class="separator:af4ff3d0e22aa7d489b9713054847ede8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d6b5d5cc2b2d8af985b1dbd0502070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1proxy_1_1Proxy.html#a97d6b5d5cc2b2d8af985b1dbd0502070">setLocal</a> (unsigned long, bool upToDate=false)</td></tr>
<tr class="separator:a97d6b5d5cc2b2d8af985b1dbd0502070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74c37de9fac6cba1cc92273145aed35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1proxy_1_1Proxy.html#ac74c37de9fac6cba1cc92273145aed35">synchronize</a> ()</td></tr>
<tr class="separator:ac74c37de9fac6cba1cc92273145aed35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8fbd932d721c01ff821f975186928aa9"><td class="memItemLeft" align="right" valign="top"><a id="a8fbd932d721c01ff821f975186928aa9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>proxy::obj_size_multi_fn</b> (void *data, int num_gid_entries, int num_lid_entries, int num_ids, ZOLTAN_ID_PTR global_ids, ZOLTAN_ID_PTR local_ids, int *sizes, int *ierr)</td></tr>
<tr class="separator:a8fbd932d721c01ff821f975186928aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926e4954523eb64db10fde4985309fd4"><td class="memItemLeft" align="right" valign="top"><a id="a926e4954523eb64db10fde4985309fd4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>proxy::pack_obj_multi_fn</b> (void *data, int num_gid_entries, int num_lid_entries, int num_ids, ZOLTAN_ID_PTR global_ids, ZOLTAN_ID_PTR local_ids, int *dest, int *sizes, int *idx, char *buf, int *ierr)</td></tr>
<tr class="separator:a926e4954523eb64db10fde4985309fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce8f505649732d664745c071055dad5"><td class="memItemLeft" align="right" valign="top"><a id="a3ce8f505649732d664745c071055dad5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>proxy::unpack_obj_multi_fn</b> (void *data, int num_gid_entries, int num_ids, ZOLTAN_ID_PTR global_ids, int *sizes, int *idx, char *buf, int *ierr)</td></tr>
<tr class="separator:a3ce8f505649732d664745c071055dad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The proxy can be used to locate ANY nodes currently accessible from the associated <a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1DistributedGraph.html">DistributedGraph</a>, including GhostNodes.</p>
<p>The corresponding maps are maintained externally at the <a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1DistributedGraph.html">DistributedGraph</a> scale, when nodes are imported and exported using Zoltan.</p>
<p>The <a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1proxy_1_1Proxy.html">Proxy</a> must be synchronized at each step to maintain and update the current location map using the Zoltan migrations functions. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac57c3711fb82615b38fe2748aaaf8c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57c3711fb82615b38fe2748aaaf8c6b">&#9670;&nbsp;</a></span>Proxy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FPMAS::graph::parallel::proxy::Proxy::Proxy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localProc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1proxy_1_1Proxy.html">Proxy</a> constructor.</p>
<p>The input local proc (i.e. the current MPI rank) of the proxy could be computed internally, but passing it as argument allows the value to be defined as const.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localProc</td><td>current MPI rank </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a576ec70cdd4ad246cc06e3ac8ca9a575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576ec70cdd4ad246cc06e3ac8ca9a575">&#9670;&nbsp;</a></span>Proxy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FPMAS::graph::parallel::proxy::Proxy::Proxy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; int &gt;&#160;</td>
          <td class="paramname"><em>ranks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds a proxy managing the specified ranks.</p>
<p>Because the proxy instanciates a new MpiCommunicator, this constructor follows the same requirements as MpiCommunicator(std::initializer_list&lt;int&gt;).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localProc</td><td>current MPI rank </td></tr>
    <tr><td class="paramname">ranks</td><td>ranks to include in this proxy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af4ff3d0e22aa7d489b9713054847ede8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ff3d0e22aa7d489b9713054847ede8">&#9670;&nbsp;</a></span>getCurrentLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FPMAS::graph::parallel::proxy::Proxy::getCurrentLocation </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current location of the node corresponding to the specified id.</p>
<p>If the <a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1proxy_1_1Proxy.html">Proxy</a> is properly synchronized, it is ensured that the node is really living on the returned proc, what means that its associated data can be asked directly to that proc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>node id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b90abd4c342da8219e3b317875e95a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b90abd4c342da8219e3b317875e95a3">&#9670;&nbsp;</a></span>getLocalProc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FPMAS::graph::parallel::proxy::Proxy::getLocalProc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the localProc associated to this proxy, that should correspond to the current MPI rank.</p>
<dl class="section return"><dt>Returns</dt><dd>local proc </dd></dl>

</div>
</div>
<a id="ae32ea09361e39373cff62ba1de5ea244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32ea09361e39373cff62ba1de5ea244">&#9670;&nbsp;</a></span>getOrigin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FPMAS::graph::parallel::proxy::Proxy::getOrigin </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the origin rank of the node corresponding to the specified id.</p>
<p>The origin of node is actually used as the reference proxy from which we can get the updated current location of the node.</p>
<p><code>localProc</code> is returned if the origin of the node is the current proc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>node id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d9c8f41ffb64f655ad8cb787990cbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9c8f41ffb64f655ad8cb787990cbf7">&#9670;&nbsp;</a></span>setCurrentLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FPMAS::graph::parallel::proxy::Proxy::setCurrentLocation </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>proc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the current location of the node corresponding to the specified id to proc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>node id </td></tr>
    <tr><td class="paramname">proc</td><td>current location rank of the corresponding node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97d6b5d5cc2b2d8af985b1dbd0502070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d6b5d5cc2b2d8af985b1dbd0502070">&#9670;&nbsp;</a></span>setLocal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FPMAS::graph::parallel::proxy::Proxy::setLocal </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upToDate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the current proc as the current location of the node corresponding to the specified id.</p>
<p>A <code>true</code> value for upToDate might be used when the next call to <a class="el" href="classFPMAS_1_1graph_1_1parallel_1_1proxy_1_1Proxy.html#ac74c37de9fac6cba1cc92273145aed35">synchronize()</a> does not need to send update information for this node, typically when the node has just been imported locally directly from its origin (in this case, the origin already has an updated information about the node's current location). In any other case, or in case of doubt, let <code>upToDate</code> to its default <code>false</code> value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>id of the local node </td></tr>
    <tr><td class="paramname">upToDate</td><td>true if no update information needs to be called for this node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a599bab0819fb0dd336120fa954571ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599bab0819fb0dd336120fa954571ac2">&#9670;&nbsp;</a></span>setOrigin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FPMAS::graph::parallel::proxy::Proxy::setOrigin </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>proc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the origin of the node corresponding to the specified id to proc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>node id </td></tr>
    <tr><td class="paramname">proc</td><td>origin rank of the corresponding node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac74c37de9fac6cba1cc92273145aed35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74c37de9fac6cba1cc92273145aed35">&#9670;&nbsp;</a></span>synchronize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FPMAS::graph::parallel::proxy::Proxy::synchronize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates proxies data with actual nodes current locations.</p>
<p>Each process will be waiting until everybody calls this function.</p>
<p>Updates are performed in two steps.</p><ol type="1">
<li>Each process sends the current location of its local nodes (so that this location is obviously the current process) to the corresponding origin processes. In the same step, each origin imports locations and updates its current locations table.</li>
<li>For each node not contained in the current process, the proxy asks for their current location to the corresponding origin, that is now updated from step 1.</li>
</ol>
<p>This function should be called by all the processes each time a node might have migrated somewhere in the global execution, when load balancing is performed for example. If this requirement is met, the implementation ensures that all the simulation proxies contain updated information about each node location, and so can contact them or ask their data directly. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/main/graph/parallel/proxy/<a class="el" href="proxy_8h_source.html">proxy.h</a></li>
<li>src/main/graph/parallel/proxy/proxy.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
